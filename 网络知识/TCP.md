# TCP/IP

### **1.简述tcp的三次握手**

**初始状态：**客户端处于关闭状态，服务器处于监听状态

**第一次握手：**客户端向服务器发送SYN报文，并且随机初始化一个序列号作为seq的值，Client进入SYN_SENT状态，等待Server确认

**第二次握手：**服务器收到数据包之后由SYN=1知道客户端请求建立连接，客户端将ACK和SYN都置为1，ack = seq.val  随机初始化一个序列号为seq的值，并且将数据包发给客户端，进入确认连接的状态

**第三次握手**：客户端收到之后，检查ack是不是之前初始化的序列号的值+1，检查ACK是不是1，如果正确则将标志位ACK置为1，ack=之前服务器上初始化的seq的值加+1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

### **2.为什么需要第三次握手**

因为在网络中由许多不可控的事情，没有办法保证第一次握手发送的数据及时的到达服务端，如果没有第三次的握手，服务器收到网络中已经丢弃的请求连接的数据，回传给客户端就已经建立了一次TCP的连接，这样显然浪费的网络资源。第三次握手的意义就在于**防止服务器一直等待而浪费资源**

### **3.握手过程中可以携带数据吗？为什么？**

**第一次握手不可以**，如果第一次握手就可以携带数据的话，有人要恶意的攻击服务器，那就会在第一次握手的数据包中放入大量的数据，并在短时间内大量发送SYN报文。

**第三次握手可以**，因为第三次的握手已经确认服务器和客户端的接受和发送能力都是没问题的。

### **4.四次挥手**

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

**第一次挥手**：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，Client进入FIN_WAIT_1状态。

**第二次挥手**：：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

**第三次挥手**：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

**第四次挥手**：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

TCP协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不 会被释放。
网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。
在众多TCP状态中，最值得 注意的状态有两个：CLOSE_WAIT和TIME_WAIT

**1、LISTENING状态**

FTP服务启动后首先处于侦听（LISTENING）状态。

**2、ESTABLISHED状态**

ESTABLISHED的意思是**建立连接。表示两台机器正在通信**。

**3、CLOSE_WAIT**

​    对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭

**4、TIME_WAIT**

 **我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT**。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。

目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。

5、SYN_SENT状态

　 　SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。 根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟,即240秒,TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。

#### 5.为什么要等待2MSL？

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。
有以下两个原因：

- **第一点：保证TCP协议的全双工连接能够可靠关闭**：
  由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于`CLOESD`状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。
- **第二点：保证这次连接的重复数据段从网络中消失**
  如果Client端发送最后的ACK直接进入`CLOSED`状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。