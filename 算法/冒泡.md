

# 常见的排序算法分类

![img](https://user-gold-cdn.xitu.io/2019/6/20/16b734e55623a2e4?imageslim)



## 冒泡排序

**什么是冒泡排序**

将相邻的两个元素进行比较，按照统一的规则（从大到小、从小到大）重新调整顺序

通俗来讲就是：最大的或者最小的元素会在每趟排序之后冒泡到最底层或者最上层

就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

**算法原理**

- 比较相邻两个元素，如果和规定的顺序不符合，就交换
- 每走一趟，没有排序的元素中就有一个最大的或者最小的元素排到最后
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![img](C:\Users\liuxz\Desktop\myWeb\2021校招\面试准备\知识点积累\1)

## **算法分析**

**时间复杂度**

冒泡排序最好的时间复杂度为O(n) 。

冒泡排序的最坏时间复杂度为 O(n^2)。

因此冒泡排序总的平均时间复杂度为O(n^2)。

**算法稳定性**

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

**算法实现（js）**

```js
for(var i = 0 ; i < array.length - 1; i++){ 
    for(var j = 0 ; j < array.length - 1 -i ; j ++ ){
        if(array[j] > array[j+1]){
            let temp = array[j]
            array[j] = array[j+1];
            array[j+1] = temp;
        }
    }
}
```

**优化**

如果一趟排序都没有发生交换，表示已经有序了，没必要进行接下来的排序了。 可以定义一个 **flag** ，初始值为false，如果发生交换，就赋值为true，否则一直是false直接退出循环。 代码如下：

```js
boolean flag = false;//表示是否进行交换
for(var i = 0 ; i < array.length - 1; i++){ 
    for(var j = 0 ; j < array.length - 1 -i ; j ++ ){
        if(array[j] > array[j+1]){
            flag = true ;
            let temp = array[j]
            array[j] = array[j+1];
            array[j+1] = temp;
        }
    }
    if(!flag){
        break;
    }else{
        flag = false;
    }
}
```

